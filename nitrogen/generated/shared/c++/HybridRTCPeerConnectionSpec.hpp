///
/// HybridRTCPeerConnectionSpec.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/HybridObject.hpp>)
#include <NitroModules/HybridObject.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif

// Forward declaration of `RTCPeerConnectionState` to properly resolve imports.
namespace margelo::nitro::webrtc { enum class RTCPeerConnectionState; }
// Forward declaration of `RTCIceGatheringState` to properly resolve imports.
namespace margelo::nitro::webrtc { enum class RTCIceGatheringState; }
// Forward declaration of `Event` to properly resolve imports.
namespace margelo::nitro::webrtc { struct Event; }
// Forward declaration of `RTCPeerConnectionIceEvent` to properly resolve imports.
namespace margelo::nitro::webrtc { struct RTCPeerConnectionIceEvent; }
// Forward declaration of `RTCTrackEvent` to properly resolve imports.
namespace margelo::nitro::webrtc { struct RTCTrackEvent; }
// Forward declaration of `RTCConfiguration` to properly resolve imports.
namespace margelo::nitro::webrtc { struct RTCConfiguration; }
// Forward declaration of `RTCSessionDescriptionInit` to properly resolve imports.
namespace margelo::nitro::webrtc { struct RTCSessionDescriptionInit; }
// Forward declaration of `RTCIceCandidateInit` to properly resolve imports.
namespace margelo::nitro::webrtc { struct RTCIceCandidateInit; }
// Forward declaration of `HybridRTCRtpTransceiverSpec` to properly resolve imports.
namespace margelo::nitro::webrtc { class HybridRTCRtpTransceiverSpec; }
// Forward declaration of `HybridMediaStreamTrackSpec` to properly resolve imports.
namespace margelo::nitro::webrtc { class HybridMediaStreamTrackSpec; }
// Forward declaration of `RTCRtpTransceiverInit` to properly resolve imports.
namespace margelo::nitro::webrtc { struct RTCRtpTransceiverInit; }

#include "RTCPeerConnectionState.hpp"
#include "RTCIceGatheringState.hpp"
#include <string>
#include "Event.hpp"
#include <functional>
#include <optional>
#include "RTCPeerConnectionIceEvent.hpp"
#include "RTCTrackEvent.hpp"
#include "RTCConfiguration.hpp"
#include <NitroModules/Promise.hpp>
#include "RTCSessionDescriptionInit.hpp"
#include <NitroModules/Null.hpp>
#include "RTCIceCandidateInit.hpp"
#include <variant>
#include <memory>
#include "HybridRTCRtpTransceiverSpec.hpp"
#include "HybridMediaStreamTrackSpec.hpp"
#include "RTCRtpTransceiverInit.hpp"
#include <vector>

namespace margelo::nitro::webrtc {

  using namespace margelo::nitro;

  /**
   * An abstract base class for `RTCPeerConnection`
   * Inherit this class to create instances of `HybridRTCPeerConnectionSpec` in C++.
   * You must explicitly call `HybridObject`'s constructor yourself, because it is virtual.
   * @example
   * ```cpp
   * class HybridRTCPeerConnection: public HybridRTCPeerConnectionSpec {
   * public:
   *   HybridRTCPeerConnection(...): HybridObject(TAG) { ... }
   *   // ...
   * };
   * ```
   */
  class HybridRTCPeerConnectionSpec: public virtual HybridObject {
    public:
      // Constructor
      explicit HybridRTCPeerConnectionSpec(): HybridObject(TAG) { }

      // Destructor
      ~HybridRTCPeerConnectionSpec() override = default;

    public:
      // Properties
      virtual RTCPeerConnectionState getConnectionState() = 0;
      virtual RTCIceGatheringState getIceGatheringState() = 0;
      virtual std::string getLocalDescription() = 0;
      virtual std::string getRemoteDescription() = 0;
      virtual std::optional<std::function<void(const Event& /* event */)>> getOnconnectionstatechange() = 0;
      virtual void setOnconnectionstatechange(const std::optional<std::function<void(const Event& /* event */)>>& onconnectionstatechange) = 0;
      virtual std::optional<std::function<void(const Event& /* event */)>> getOnicegatheringstatechange() = 0;
      virtual void setOnicegatheringstatechange(const std::optional<std::function<void(const Event& /* event */)>>& onicegatheringstatechange) = 0;
      virtual std::optional<std::function<void(const RTCPeerConnectionIceEvent& /* event */)>> getOnicecandidate() = 0;
      virtual void setOnicecandidate(const std::optional<std::function<void(const RTCPeerConnectionIceEvent& /* event */)>>& onicecandidate) = 0;
      virtual std::optional<std::function<void(const RTCTrackEvent& /* event */)>> getOntrack() = 0;
      virtual void setOntrack(const std::optional<std::function<void(const RTCTrackEvent& /* event */)>>& ontrack) = 0;

    public:
      // Methods
      virtual void setConfiguration(const std::optional<RTCConfiguration>& config) = 0;
      virtual void close() = 0;
      virtual std::shared_ptr<Promise<void>> setLocalDescription(const std::optional<RTCSessionDescriptionInit>& description) = 0;
      virtual std::shared_ptr<Promise<void>> setRemoteDescription(const RTCSessionDescriptionInit& description) = 0;
      virtual std::shared_ptr<Promise<void>> addIceCandidate(const std::optional<std::variant<nitro::NullType, RTCIceCandidateInit>>& candidate) = 0;
      virtual std::shared_ptr<HybridRTCRtpTransceiverSpec> addTransceiver(const std::variant<std::shared_ptr<HybridMediaStreamTrackSpec>, std::string>& trackOrKind, const std::optional<RTCRtpTransceiverInit>& init) = 0;
      virtual std::vector<std::shared_ptr<HybridRTCRtpTransceiverSpec>> getTransceivers() = 0;
      virtual std::shared_ptr<Promise<RTCSessionDescriptionInit>> createOffer() = 0;
      virtual std::shared_ptr<Promise<RTCSessionDescriptionInit>> createAnswer() = 0;

    protected:
      // Hybrid Setup
      void loadHybridMethods() override;

    protected:
      // Tag for logging
      static constexpr auto TAG = "RTCPeerConnection";
  };

} // namespace margelo::nitro::webrtc
